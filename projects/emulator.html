<!DOCTYPE html>
<html>
<head>
	<title>Maddie Burbage</title>
	<!-- link to site's main stylesheet -->
	<link rel="stylesheet" type="text/css" href="/css/main.css">
  <link rel="stylesheet" type="text/css" href="/css/paneling.css">
	<script src="/js/scroller.js"></script>
  <link href="https://fonts.googleapis.com/css?family=Abel|Courgette&display=swap" rel="stylesheet">
</head>
<body>
	<header>
		<h1>Maddie Burbage</h1>
		<ul>
      		<li><a href="/">Home</a></li>
      		<li><a href="/about.html">About</a></li>
      		<li><a href="/projects.html">Projects</a></li>
		</ul>
	</header>
	<div class = "container">
    <img class = "icon" src="/pictures/Emulator.png" alt="RISC to CISC emulator">
		<span class ="info">
      <h2 style="display:inline;">RISC Assembly Emulator</h2>
      <p style="display:inline;">(April/May 2019)</p>
      <p>Efficient emulator for Reduced Instruction Set Computer assembly code using Complex
			Instruction Set Computer assembly code. Created with a partner for the final
			project in my computer architecture class.</p>
		</span>
		<div class = "panels">
      <div class = "panel right">
        <h2>Decoding</h2>
        <p>Before starting any optimization, we needed to design a systematic decoder for machine code
				instructions produced by the RISC assembly. The first step was identifying parts of
				instructions: what operations would be attempted, the source and shifts of the inputs, and
				whether the instruction was conditional. After masking the instruction code by these parts the
				decoder would branch to code that used registers to act out operations, and then would save
				outputs to virtual registers in memory. </p>
      </div>
      <div class = "panel">
        <h2>Considerations</h2>
        <p>From there the project grew trickier. Conditionals and program counter changes were
				the most painstaking implementations. Since our RISC assembly language (similar to ARM's)
				used condition flags and conditional execution, it added many lines of complexity for decoding
				each instruction. The RISC assembly language also allowed any register-altering operation to
				potentially alter the program counter. When this happened, the program counter wouldn't be
			 	incremented before decoding the next instruction. However, the size of memory accessible to the
				RISC assembly was smaller than the memory that the CISC code performed in, and thus RISC pointers
				were also smaller. So these alterations to the program counter had to be safely checked to prevent
				odd behavior or vulnerabilities in emulation.</p>
      </div>
      <div class = "panel right">
        <h2>Optimization</h2>
        <p>Rather than focusing primarily on speed or memory usage, we designed our program to
				work efficiently on both ends. This often meant selectively choosing which processes to
				optimize. Often longer blocks of code with more initial branching would drastically speed
				up the program but would also take much more space to implement, so for every redesign of a
				section of decoding we thoroughly tested whether the increase in speed was worth it. We also
				measured the most common elements of instructions so we could add shortcuts for decoding those
				instruction types.</p>
      </div>
    </div>
	</div>
	<footer>
		<ul>
      		<li><a href="https://www.linkedin.com/in/maddieburbage/">Linkedin</a></li>
			<li><a href="mailto:madeline.g.burbage@gmail.com">Email</a></li>
			<li><a href="https://github.com/maddieburbage">Github</a></li>
		</ul>
	</footer>

</body>
</html>
